---
title: "Ortolan Bunting analysis"
author: "me"
date: "9 joulukuuta 2019"
output: html_document
---

# 2. Peltosirkkuaineiston analyysi

Tutkimuskysymykset:  

1) Peltosirkun häviämisnopeus kasvaa alueen avoimuuden vähentyessä ja eristyneisyyden kasvaessa  

2) Peltosirkun häviämisnopeus kasvaa peltoviljelyn muuttuessa viljavaltaisesta nurmivaltaiseksi  

3) Peltosirkun häviämisnopeus kasvaa viljelyn monimuotoisuuden vähentyessä  

4) Peltosirkun häviämisnopeus kasvaa maiseman pienipiirteisten rakenteiden yksipuolistuessa  



```{r, include=FALSE}
getwd()
paketit<-c("readr","tidyr","plyr","dplyr","vegan","ggplot2","lattice","psych","glmmTMB","lme4","MASS","MuMIn","mgcv","gamm4")
lapply(paketit,library,character.only=T)
```


## 2.1 Aineiston tarkastelua

Luetaan aineisto sisään ja tarkistetaan, että luokkamuuttujat ovat oikein ja ettei joukossa ole NA:ta:

```{r}
data<-read.csv("OrtolanBunting.csv")

names(data)
str(data)
summary(data)

#tarkasta kaikkien luokkien muoto
data$id<-as.factor(data$id)
#vuodelle oma faktori-muuttuja
data$fyear<-as.factor(data$year)
```

### 2.1.1 Poikkeavia havaintoja

Tarkastellaan havaintoja yksitellen, onko mukana virheitä tai poikkeavia havaintoja:
```{r}
#outliers
dotchart(data$terri, main= "N territories")
dotchart(data$prec, main= "precipitation")
dotchart(data$temp, main= "temperature")
dotchart(data$open, main= "open (spring sown)")
dotchart(data$SSS, main= "SSS (small-scale structures)")
dotchart(data$shan, main= "shannon")
dotchart(data$shanG, main= "shannon, crop types")
```

Kuinka monta reviiriä per osapopulaatio?
```{r}
hist(data$terri)
table(data$terri)
```

Aineistossa on muutama "MEGA"osapopulaatio. Suurimmaksi osaksi osapopulaatiot ovat tyhjiä tai niillä on muutama reviiri.  

Kuinka monta käyntikertaa per osapopulaatio?

```{r}
sort(table(data$id))
```

Muutamalla osapopulaatiolla on käyty vain kerran.


### 2.1.2 Riippuvuussuhteita

Tarkastellaan muuttujia suhteessa toisiinsa:

```{r, fig.width=14, fig.height=12}
#relationships
pairs.panels(data[,c(3:22)])
```

Reviirien lukumäärällä (terri) ja Shannon-Wienerin indeksillä (shan ja shanG) sekä lajien lukumäärällä (snum) on suht vahva korrelaatio. Myös maatalousmaiseman osuus (agri5) ja pienrakenteiden tiheys (SSS) nousevat esille. Huomaa, että teiden ja rakennusten suhde reviirien määrään on negatiivinen, kun taas jokien ja purojen on positiivinen.

Keväällä kylvettävien kasvien osuus (open) ja keväällä pidemmällä oraalla olevien kasvien (cover) osuudet ovat toistensa vastakohdat.


### 2.1.3 Lisää plottailua

Katsotaan reviirien määrän kehitystä kullakin osapopulaatiolla:

```{r, fig.width=14, fig.height=12}
#plottailua
xyplot(terri~fyear|id, data=data)
boxplot(terri~fyear, data=data)
```

Trendi näyttäisi yleisesti olevan laskeva.



## 2.2 Mallit

Peruspiirteittäin suunniteltiin mallit näin:

M1 = year  

M2 = year + kov  

M3 = year + kov + weather x year  

M4 = year + kov + pelto x year  

M5 = year + kov + weather x year + pelto x year  


Kov(ariaatit) tarkoittaa SSS, agri5 ja koordinaatteja. ("pakolliset kovariaatit")  
Weather tarkoittaa sadantaa ja lämpötilaa.  
Pelto tarkoittaa shannon-indeksiä ja avoimen maan osuutta (open).

### 2.2.1 Nested/crossed, hierarchical ja muita ajatuksia

```{r}
#Aksun esimerkit (näissä mukana NDVI):
#m1=glmmTMB(N ~Year + (1|fYear) + (1|Site), family=nbinom2, data=Embhor) 
#m2=glmmTMB(N ~SSS + Landscape + X + Y + X*Y + Year + (1|fYear) + (1|Site), family=nbinom2, data=Embhor) 
#m3=glmmTMB(N ~SSS + Landscape + X + Y + X*Y + Year*Temp + Year*Rain + Year*NDVI + (1|fYear) + (1|Site), family=nbinom2, data=Embhor)
#m4=glmmTMB(N ~SSS + Landscape + X + Y + X*Y + Year*Cropdiv + Year*Plough + (1|fYear) + (1|Site), family=nbinom2, data=Embhor)
#m5=glmmTMB(N ~SSS + Landscape + X + Y + X*Y + Year*Temp + Year*Rain + Year*NDVI + Year*Cropdiv + Year*Plough + (1|fYear) + (1|Site), family=nbinom2, data=Embhor)
```

Mikään malleista ei aluksi toiminut, koska aineisto oli skaalaamaton. Alla kuitenkin asioita, joita tuli pohdittua ongelmaa selvittäessä:  

Muuttuja 'id' eli jokaisen osapopulaaation yksilöivä tunniste on random-muuttuja koska se saattaa sisältää jotain informaatiota, jota fixed-muuttujat eivät sisällä koska koko populaatio ei ole täydellisesti edustettuna otoksessa.  

Määritelmiä siitä, milloin effect on fixed tai random: "Effects are fixed if they are interesting in themselves or random if there is interest in the underlying population. When a sample exhausts the population, the corresponding variable is fixed; when the sample is a small (i.e., negligible) part of the population the corresponding variable is random".  

Mutta entäpä vuosi?  

Random-efektinä vuosi huomioisi vuosien välisen ajallisen riippuvuuden. Osapopulaatiolla, jolla on monta lauluryhmää yhtenä vuonna, on suuremmalla todennäköisyydellä monta lauluryhmää myös seuraavana vuonna.  
Fixed-efektinä se selittäisi lauluryhmien määrässä tapahtuvaa vaihtelua suoraan. Vuodet ovat erilaisia (esim. tapahtumat Afrikassa vaihtelevat) ja jokin asia, jota emme ole tajunneet mitata voi selittyäkin vuodella.  


Muuttuja sekä fixed että random-tekijänä?  

Lue aiheesta [täältä](https://www.theanalysisfactor.com/mixed-models-predictor-both-fixed-random/). Voiko vuosi siis olla fixed effect vain silloin kun se on interaktiossa jonkun toisen muuttujan kanssa? 


Nested or crossed?

Relatively few mixed effect modeling packages can handle crossed random effects, i.e. those where one level of a random effect can appear in conjunction with more than one level of another effect. (This definition is confusing, and I would happily accept a better one.) A classic example is crossed temporal and spatial effects. If there is random variation among temporal blocks (e.g. years) ‘’and’‘random variation among spatial blocks (e.g. sites),’‘and’‘if there is a consistent year effect across sites and’‘vice versa’’, then the random effects should be treated as crossed. 

Selkeä vastaus lötyy [täältä](https://stats.stackexchange.com/questions/228800/crossed-vs-nested-random-effects-how-do-they-differ-and-how-are-they-specified).


Random-muuttujan havaintojen määrä?  

Joillain osapopulaatioilla on käyty vain kerran, joillain taas täydet 19 kertaa. Jos osapopulaatio on random-tekijä täytyy siitä olla havaintoja useampia. Muuten ei pysty arvioimaan ryhmän sisäistä vaihtelua? Katso kysymys [aiheesta](https://stats.stackexchange.com/questions/242821/how-will-random-effects-with-only-1-observation-affect-a-generalized-linear-mixe). Vastaus on kai, että ei haittaa, kunhan vaihtelun saa arvioitua muista osapopulaatioista, joista on useampia havaintoja. 

Muuttujien skaalaaminen?

Vuoden keskittäminen? Vuosi 2000 olisi baseline ja siitä eteenpäin vuosi 1,2,3 jne. Tai Cyear = year-mean(year). Uusi muuttuja.

### 2.2.2 GLMM-mallit

#### Ei pinta-alaa mukana

Skaalataan aineisto ja kokeillaan glmm-malleja. Sovitetaan viisi hypoteesiemme mukaista glmm-mallia ja tulostetaan niiden AICc-taulukko: 

```{r}
dataS=data %>%mutate_at(c(2:3,5:7,9:14,20:21), funs(c(scale(.))))

M1=glmmTMB(terri ~ year + (1|fyear)+ (1|id), family=nbinom2, data=dataS, REML=FALSE)

M2=glmmTMB(terri ~ SSS + agri5 + X*Y + year + (1|fyear) + (1|id), family=nbinom2, data=dataS, REML=FALSE)

M3=glmmTMB(terri ~ SSS + agri5 + X*Y + year*temp + year*prec  + (1|fyear)  + (1|id), family=nbinom2, data=dataS, REML=FALSE)

M4=glmmTMB(terri ~ SSS + agri5 + X*Y + year*shan + year*open + (1|fyear) + (1|id), family=nbinom2, data=dataS, REML=FALSE)

M5=glmmTMB(terri ~ SSS + agri5 + X*Y + year*temp + year*prec + year*shan + year*open + (1|fyear) + (1|id), family=nbinom2, data=dataS, REML=FALSE)

output1<-model.sel(M1,M2,M3,M4,M5) 

# AICc Table
output1
```

Taulukon mukaan mallit M4 ja M5 ovat parhaimpia, 1.83 AICc yksikön erolla toisistaan. Mallit eroavat toisistaan vuoden ja lämpötilan sekä sadannan interaktioiden suhteen. M4 on yksinkertaisempi eli ilman ilmastomuuttujia.

Tehdään model averaging M4 ja M5 malleilla:

```{r}
output2=model.sel(M4,M5)

#tehdään model averaging
summary(model.avg(output2, revised.var = TRUE))
```

Taulukon tulkinta on hieman epäselvää mulle. Taulukkohan vihjaa ettei interaktiot olisi merkittäviä, mutta mehän halutaan tutkia nimenomaan interaktioita koska ne linkittyvät asioihin, jotka kertovat reviirien lukumäärän vuosittaisesta muutoksesta. Muuttujien tutkiminen ilman interaktiota vuoden kanssa ei ole tässä tapauksessa mielekästä, koska se selittäisi ennemminkin asioita, jotka vaikuttavat reviirien absoluuttiseen lukumäärään, ei muutokseen. Ko,kö?

```{r}
summary(M4)
```

Mä jatkaisin tästä karsimalla mallista pois ei-merkitsevät interaktiot ja muuttujat. Mulla on tässä prosessissa vähän logiikka hakusessa.

Mallin validointi:
```{r}
#malli uudelleen, ML-asetuksella
M4=glmmTMB(terri ~ SSS + agri5 + X*Y + year*shan + year*open + (1|fyear) + (1|id), family=nbinom2, data=dataS)

op<-par(mfrow=c(3,3),mar=c(5,4,1,2))
#plot(M4,add.smooth = F,which =1)
E<-resid(M4)
hist(E, xlab = "residuals",main = "")
plot(dataS$SSS,E,xlab = "SSS",ylab="residuals")
plot(dataS$year,E,xlab = "year",ylab="residuals")
plot(dataS$shan,E,xlab = "shan",ylab="residuals")
plot(dataS$agri5,E,xlab = "agri5",ylab="residuals")
plot(dataS$open,E,xlab = "open",ylab="residuals")
plot(dataS$X,E,xlab = "X",ylab="residuals")
plot(dataS$Y,E,xlab = "Y",ylab="residuals")
par(op)
```

Hmm.. 


#### Pinta-ala offsettina:


```{r}
M1=glmmTMB(terri ~ year + offset(log(area)) + (1|fyear)+ (1|id), family=nbinom2, data=dataS, REML=FALSE)

M2=glmmTMB(terri ~ SSS + agri5 + X*Y + year + offset(log(area))+ (1|fyear) + (1|id), family=nbinom2, data=dataS,REML=FALSE)

M3=glmmTMB(terri ~ SSS + agri5 + X*Y + year*temp + year*prec  + offset(log(area))+ (1|fyear)  + (1|id), family=nbinom2, data=dataS,REML=FALSE)

M4=glmmTMB(terri ~ SSS + agri5 + X*Y + year*shan + year*open + offset(log(area))+ (1|fyear) + (1|id), family=nbinom2, data=dataS,REML=FALSE)

M5=glmmTMB(terri ~ SSS + agri5 + X*Y + year*temp + year*prec + year*shan + year*open + offset(log(area))+ (1|fyear) + (1|id), family=nbinom2, data=dataS,REML=FALSE)

output1<-model.sel(M1,M2,M3,M4,M5) 
output1
```

```{r}
output2=model.sel(M4,M2)

#tehdään model averaging
summary(model.avg(output2, revised.var = TRUE))
```

M2 olisi näistä vaihtoehdoista yksinkertaisin.


Mallin validointi:
```{r}
#malli uudelleen, ML-asetuksella
M2=glmmTMB(terri ~ SSS + agri5 + X*Y + year + offset(log(area))+ (1|fyear) + (1|id), family=nbinom2, data=dataS)
summary(M2)

op<-par(mfrow=c(3,3),mar=c(5,4,1,2))
E<-resid(M2)
hist(E, xlab = "residuals",main = "")
plot(dataS$SSS,E,xlab = "SSS",ylab="residuals")
plot(dataS$year,E,xlab = "year",ylab="residuals")
plot(dataS$shan,E,xlab = "shan",ylab="residuals")
plot(dataS$agri5,E,xlab = "agri5",ylab="residuals")
plot(dataS$open,E,xlab = "open",ylab="residuals")
plot(dataS$X,E,xlab = "X",ylab="residuals")
plot(dataS$Y,E,xlab = "Y",ylab="residuals")
par(op)
```

Vaikuttaisi siltä, että ainoita merkitseviä tekijöitä ovat vuosi, agri5 ja Y-koordinaatti. 

Residuaalien tulkinta on mulla vähän hakusessa.  


#### Pinta-ala kovariaattina:

Samat mallit mutta niin, että pinta-ala onkin oma kovariaattinsa.

```{r}
M1=glmmTMB(terri ~ year + log(area) + (1|fyear)+ (1|id), family=nbinom2, data=dataS, REML=FALSE)

M2=glmmTMB(terri ~ SSS + agri5 + X*Y + year + log(area)+ (1|fyear) + (1|id), family=nbinom2, data=dataS, REML=FALSE)

M3=glmmTMB(terri ~ SSS + agri5 + X*Y + year*temp + year*prec  + log(area)+ (1|fyear)  + (1|id), family=nbinom2, data=dataS, REML=FALSE)

M4=glmmTMB(terri ~ SSS + agri5 + X*Y + year*shan + year*open + log(area)+ (1|fyear) + (1|id), family=nbinom2, data=dataS, REML=FALSE)

M5=glmmTMB(terri ~ SSS + agri5 + X*Y + year*temp + year*prec + year*shan + year*open + log(area) + (1|fyear) + (1|id), family=nbinom2, data=dataS, REML=FALSE)

output1<-model.sel(M1,M2,M3,M4,M5) 
output1
```


```{r}
output2=model.sel(M4,M2)

#tehdään model averaging
summary(model.avg(output2, revised.var = TRUE))
```

M2 näyttäisi paremmalta valinnalta.

Mallin validointi:
```{r}
#malli uudelleen, ML-asetuksella
M2=glmmTMB(terri ~ SSS + agri5 + X*Y + year + log(area)+ (1|fyear) + (1|id), family=nbinom2, data=dataS)
summary(M2)

op<-par(mfrow=c(3,3),mar=c(5,4,1,2))
E<-resid(M2)
hist(E, xlab = "residuals",main = "")
plot(dataS$SSS,E,xlab = "SSS",ylab="residuals")
plot(dataS$year,E,xlab = "year",ylab="residuals")
plot(dataS$shan,E,xlab = "shan",ylab="residuals")
plot(dataS$agri5,E,xlab = "agri5",ylab="residuals")
plot(dataS$open,E,xlab = "open",ylab="residuals")
plot(dataS$X,E,xlab = "X",ylab="residuals")
plot(dataS$Y,E,xlab = "Y",ylab="residuals")
plot(log(dataS$area),E,xlab = "log(area)",ylab="residuals")
par(op)
```

Pinta-alan laittaminen kovariaatiksi ei näytä muuttuvan tuloksia pääpiirteissään. Log(area) on merkitsevä.


#### SSS muuttuja pilkottuna

Testaan huvikseen mallia, jossa SSS onkin korvattu osatekijöillään.

```{r}
M1=glmmTMB(terri ~ year + offset(log(area)) + (1|fyear)+ (1|id), family=nbinom2, data=dataS, REML=FALSE)

M2=glmmTMB(terri ~ Abuild + Astream + Aroad + Ariver + agri5 + X*Y + year + offset(log(area))+ (1|fyear) + (1|id), family=nbinom2, data=dataS, REML=FALSE)

M3=glmmTMB(terri ~ Abuild + Astream + Aroad + Ariver + agri5 + X*Y + year*temp + year*prec  + offset(log(area))+ (1|fyear)  + (1|id), family=nbinom2, data=dataS, REML=FALSE)

M4=glmmTMB(terri ~ Abuild + Astream + Aroad + Ariver + agri5 + X*Y + year*shan + year*open + offset(log(area))+ (1|fyear) + (1|id), family=nbinom2, data=dataS, REML=FALSE)

M5=glmmTMB(terri ~ Abuild + Astream + Aroad + Ariver + agri5 + X*Y + year*temp + year*prec + year*shan + year*open + offset(log(area)) + (1|fyear) + (1|id), family=nbinom2, data=dataS, REML=FALSE)

output1<-model.sel(M1,M2,M3,M4,M5) 
output1
```

```{r}
output2=model.sel(M4,M2)

#tehdään model averaging
summary(model.avg(output2, revised.var = TRUE))
```

Sama homma. M2 näyttäisi paremmalta valinnalta.

Mallin validointi:
```{r}
#malli uudelleen, ML-asetuksella
M2=glmmTMB(terri ~ Abuild + Astream + Aroad + Ariver + agri5 + X*Y + year + offset(log(area))+ (1|fyear) + (1|id), family=nbinom2, data=dataS, REML=FALSE)
summary(M2)

op<-par(mfrow=c(4,3),mar=c(5,4,1,2))
E<-resid(M2)
hist(E, xlab = "residuals",main = "")
plot(dataS$Abuild,E,xlab = "buildings",ylab="residuals")
plot(dataS$Astream,E,xlab = "streams",ylab="residuals")
plot(dataS$Ariver,E,xlab = "rivers",ylab="residuals")
plot(dataS$Aroad,E,xlab = "roads",ylab="residuals")
plot(dataS$year,E,xlab = "year",ylab="residuals")
plot(dataS$shan,E,xlab = "shan",ylab="residuals")
plot(dataS$agri5,E,xlab = "agri5",ylab="residuals")
plot(dataS$open,E,xlab = "open",ylab="residuals")
plot(dataS$X,E,xlab = "X",ylab="residuals")
plot(dataS$Y,E,xlab = "Y",ylab="residuals")
plot(log(dataS$area),E,xlab = "log(area)",ylab="residuals")
par(op)
```
### 2.2.3 GAM-malli, Tweedie

Päätettiin kokeilla mallinnusta niin, että selitettävänä muuttujana onkin reviirien tiheys. Näin osapopulaatioiden vaihteleva pinta-ala saadaan paremmin huomioitua. Osapopulaatiohan oli jo aikaisemminkin random-mmuuttujana, joten pinta-alan aiheuttama vaihtelu muuttujissa oli huomioitu jo jollain tasolla, mutta ei ehkä riittävästi.

SSS eli pienten rakenteiden lukumäärä tai pituudet on suhteutettu osapopulaation pinta-alaan. Mietin, tuleeko pinta-ala tässä tapauksessa huomioitua kahteen kertaan?

Tweedie-asiaa [täällä](https://stat.ethz.ch/R-manual/R-patched/library/mgcv/html/Tweedie.html) ja mgcv-paketista [täällä](https://people.maths.bris.ac.uk/~sw15190/mgcv/tampere/mgcv.pdf) ja [täällä](https://cran.r-project.org/web/packages/mgcv/mgcv.pdf). "Tweedie is an alternative to quasi when var(y) = φµp , 1 < p < 2, and a full distribution is required (for a non-negative real response)."

Luodaan uusi muuttuja 'terriD', joka on reviirien lkm jaettuna osapopulaation pinta-alalla (reviiriä/km2):

```{r}
#reviirien tiheys
dataS$terriD=dataS$terri/dataS$area
summary(dataS$terriD)
```

Plotataan aineisto uudelleen, kaksi kuvaajaa: 

```{r, fig.width=14, fig.height=12}
#relationships
pairs.panels(dataS[,c(3:22)])
pairs.panels(dataS[,c("terriD","fyear","agri5","prec","temp","shan","open","SSS","X","Y")])

ggplot(dataS, aes(x=year,y=terriD))+ geom_point() + geom_smooth()
```

Reviiritiheys mennyt alas, ylös ja alas.

Sadanta ja lämpötila negatiivisesti korreloituneita. 

Mallien sovitus:  HJÄLP! Vaikea löytää esimerkkejä. Tässä joitain: [esim1](https://gist.github.com/gavinsimpson/6d05af9186b9f9419cca5a4507af3aa0),   



Muuttujan voi laittaa random-tekijäksi myös määrittämällä se smootherissa: s(...,bs="re")  Lue [tämä](https://stat.ethz.ch/R-manual/R-devel/library/mgcv/html/random.effects.html) ja [tämä](https://stats.stackexchange.com/questions/197952/two-methods-of-adding-random-effects-to-a-gam-give-very-different-results-why-i). Näin voi käyttää gam-funktiota, jolloin family=tw (eikä Tweedie) eikä Tweedien p-arvoa tarvitse määrittää.


```{r}
G1=gam(terriD ~  year + s(fyear,bs="re") + s(id,bs="re"), data=dataS, family=tw, REML=FALSE)

G2=gam(terriD ~  year + agri5 + SSS + s(Y) + s(X) + s(fyear,bs="re") + s(id,bs="re"), data=dataS, family=tw, REML=FALSE)

G3=gam(terriD ~ agri5 + SSS + s(Y) + s(X) + year*temp + year*prec + s(fyear,bs="re") + s(id,bs="re"), data=dataS, family=tw, REML=FALSE)

G4=gam(terriD ~ agri5 + SSS + s(Y) + s(X) + year*shan + year*open + s(fyear,bs="re") + s(id,bs="re"), data=dataS, family=tw, REML=FALSE)

G5=gam(terriD ~ agri5 + SSS + s(Y) + s(X) + year*shan + year*open + year*temp + year*prec + s(fyear,bs="re") + s(id,bs="re"), data=dataS, family=tw, REML=FALSE)

AIC(G1,G2,G3,G4,G5)
```


Mallin validointia... Vaatisi vähän syventymistä aiheeseen..


```{r, echo=TRUE}
summary(G2)
plot(G2)
G2$gam
```


### 2.2.4 GAMM, NB, offset, (1 + vuosi|lauluryhmä)

Offset argumenttina: "Can be used to supply a model offset for use in fitting. Note that this offset
will always be completely ignored when predicting, unlike an offset included in formula (this used to conform to the behaviour of lm and glm)." Eli jos argumenttina niin predicted arvot eivät huomioi offsettia. Kumpikohan olis fiksumpi?

Random-muuttujan rakenne (lmer) cheat sheet [tässä](https://stats.stackexchange.com/questions/13166/rs-lmer-cheat-sheet).


**Random intercept ja random slope malli**

V1 ~ (1+V3|V2) + V3

P1: A global intercept

P2: Random effect intercepts for V2 (i.e. for each level of V2, that level's intercept's deviation from the global intercept)

P3: A single global estimate for the effect (slope) of V3

P4: The effect of V3 within each level of V2 (more specifically, the degree to which the V3 effect within a given level deviates from the global effect of V3)

P5: The correlation between intercept deviations and V3 deviations across levels of V2

Eli intercept voi vaihdella kunkin lauluryhmän mukaan (lähtökohtaisesti joillain osapopulaatioilla on enemmän tai vähemmän reviirejä, joten yleistä mallia vääntäessä tämä vaihtelu pitää sallia ja ottaa huomioon). Random intercept malli kertoo kuinka paljon osapopulaatioiden välillä on "selittämätöntä" vaihtelua, eli vaihtelua siinä, miten paljon reviirien määrä johtuu jostain muuusta kuin fixed osan muuttujista. 

Vuoden vaikutus reviirien määrään (slope) voi myös vaihdella osapopulaatioiden välillä. Jossain lasku on jyrkempi ja jossain loivempi. Slope ja intercept voivat korreloida jossain määrin keskenään eli esimerkiksi osapopulaatioilla, joilla on enemmän reviirejä myös vuosittainen lasku reviirien määrässä on jyrkempi. Tai toisinpäin.


**Temporaalinen autokorrelaatio?** Peräkkäiset vuodet ovat reviirimäärältään samankaltaisempia kuin kauempana toisistaan olevat vuodet? corAR1 jutska.

**Miten gamm malleja vertaillaan?** AIC ei kai ihan pätevä. gamm4 ja gamm funktioilla on ilmeisesti eroa, gamm ei anna AIC arvoa. katso Zuurin pingviiniesimerkit. Miten vapausasteet lasketaan gammeilla? smoothereissa lineaarinen ja random osa? Eli yksi vai kaksi vapausastetta? Ratkaisee sen miten AIC lasketaan. Asiasta ei kai olla ihan yhtä mieltä. Zuur neuvoo tekemään analyysit Bayeslaisittain, jolloin tätä ongelmaa ei ole.

Zuurin kommentit paketin valinnasta:
# What package should we use for a GAMM?
#
# Function  Package      Uses      Object names
# gamm4      gamm4       lme4     M1$mer  M1$gam
# gamm       mgcv        nlme     M1$lme  M1$gam 

# To gamm4 or to mgcv?
# Gaussian: gamm4 or gamm
# Crossed random effects: use gamm4

# Model heterogeneity: nlme   but not in lme4. Use gamm
# Model correlation: Y_s   = Covariate stuff_s + eps_s
#                    eps_s = rho * eps_s-1 + Pure Noise
# But....this is all in nlme....(gls and lme)..so only in gamm


#Poisson/binomial: 
# Use gamm4/lme4 ....you can compare AICs
# But also in gamm....but via PQL ...therefore...cannot compare AICs 


# Adding correlation in Gaussian models:
# T1 <- gamm(Y ~ s(X), correlation = corAR1(form=~ Time))
# T1 <- gamm(Y ~ s(X), correlation = corSpher(form=~ Lat+Lon))

gamm4-funktion negbin jakaumaan pitää määritellä theta. Miten se valitaan?

Kokeilen ensin ihan vain hatusta 0.2:

```{r, eval=FALSE}
#joku smootheri mallissa täytyy olla, vai täytyykö? gamm4 näyttää toimivan ilmankin. mgcv-paketin gamm ei toiminut.
M1=gamm4(terri ~ year + offset(log(area)), random= ~(1 + year|id), family=negbin(theta=0.2), data=dataS) #gamm4-funktiolla random-argumentti on vähän erilainen, offset toimii myös erilailla

M2=gamm4(terri ~ SSS + agri5*year + s(Y) + s(X) + year + offset(log(area)), random= ~(1 + year|id), family=negbin(theta=0.2), data=dataS)

M3=gamm4(terri ~ SSS + agri5*year + s(Y) + s(X)+ year*temp + year*prec + offset(log(area)), random= ~(1 + year|id), family=negbin(theta=0.2), data=dataS)

M4=gamm4(terri ~ SSS + agri5*year + s(Y) + s(X) + year*shan + year*open + offset(log(area)), random= ~(1 + year|id), family=negbin(theta=0.2), data=dataS)

M5=gamm4(terri ~ SSS + agri5*year + s(Y) + s(X) + year*temp + year*prec + year*shan + year*open + offset(log(area)), random= ~(1 + year|id), family=negbin(theta=0.2), data=dataS)


AIC(M1$mer, M2$mer, M3$mer, M4$mer, M5$mer)

AIC(M1$mer)
````

Zuurin kaksi tapaa arvioida theta:

1) Käytetään gamm4-funktiota ja kokeillaan erilaisia thetoja, katsotaan kuvaajasta, mikä antaa parhaimman AIC arvon

```{r, eval=FALSE}
AllThetas <- c(0.1, 0.2, 0.3, 0.4, 0.6, 1, 2, 5, 10)
AICs <- vector(length = 9)
i <- 1
for (MyTheta in AllThetas) {
       M1 <- gamm4(terri ~ SSS + agri5*year + s(Y) + s(X) + year*temp + year*prec + year*shan + year*open + offset(log(area)),
                random =~ (1 + year| id),
                family = negbin(theta = MyTheta),
                data = dataS)
       AICs[i] <- AIC(M1$mer)  #<---
       i <- i + 1
}
# And plot the results
plot(x = AllThetas, 
     y = AICs,
     xlab = "Theta value in NB GAMM",
     ylab = "AIC",
     cex.lab = 1.5,
     type = "l"
    )
```

Tästä ei tule tulokseksi mitään järkeävää. Tai AIC:t vaan laskee mitä isompi theta on. Onko se järkevä tulos?

2) Käytetään gam-funktiota, jolloin family=nb() arvioi itse sopivan thetan. Tätä varten random-tekijät pitää muuttaa smoothereiksi. En tiedä osasinko tehdä tämän oikein. Eli onko random =~ (1 + year| id) sama kuin s(year,id, bs =  "re") ?

```{r, eval=FALSE}
#thetan voisi arvioida sovittamalla mallin GAM:lla eli random tekijä smootheriksi. Mutta mikä malli tässä pitäisi olla? Monimutkaisin?

M6 <- gam(terri ~ SSS + agri5*year + s(Y) + s(X) + year*temp + year*prec + year*shan + year*open + offset(log(area)) + s(year,id, bs =  "re"), family = nb(),data = dataS)
summary(M6)
Theta <- M6$family$getTheta(TRUE)


# If you want then you can run M4 again with the optimal theta.
M4 <- gamm4(terri ~ SSS + agri5*year + s(Y) + s(X) + year*temp + year*prec + year*shan + year*open + offset(log(area)),
            random = ~(1 + year|id),
            family = negbin(theta = Theta),  
            data = dataS)

# M6 and M4 should now give similar results.
summary(M6)
summary(M4$gam)
summary(M4$mer)

gam.vcomp(M6)
```

Ei nää mallit nyt ihan täsmää keskenään vaikka pitäisi. Siis jos vertailee muuttujille ja interceptille arvioituja parametreja. Ja random-muuttujien std.dev arvoja. Mutta jos tästä silti ottaisi tuon Thetan onkeensa. Eli 5.354404.

Jos tässä kokeilussa oli väärin käyttää tuota monimutkaisinta mallia niin kokeillaan sitten myös yksinkertaisemmalla mallilla. Saanko saman thetan?

```{r, eval=FALSE}
#thetan voisi arvioida sovittamalla mallin GAM:lla eli random tekijä smootheriksi. Mutta mikä malli tässä pitäisi olla? Monimutkaisin?

M6 <- gam(terri ~ year + offset(log(area)) + s(year,id, bs =  "re"), family = nb(),data = dataS)
summary(M6)
Theta2 <- M6$family$getTheta(TRUE)


# If you want then you can run M4 again with the optimal theta.
M4 <- gamm4(terri ~ year + offset(log(area)),
            random = ~(1 + year|id),
            family = negbin(theta = Theta2),  
            data = dataS)

# M6 and M4 should now give similar results.
summary(M6)
summary(M4$gam)
summary(M4$mer)

gam.vcomp(M6)
Theta2
```

Nyt theta on 2.439918 eli eroaa edellisestä arviosta. Zuurin esimerkki ei selitä mitä mallia thetan arvioinnissa pitäisi käyttää. Siinä käytetään mallia, johon on jo aiemmista kiemuroista päädytty, eikä esimerkissä tehdä mallin valintaa tämän jälkeen (etsitään vain sopiva theta ja sovitetaan negbin malli).

Nyt en oikein tiedä minkä thetan valitsisin. Toistaiseksi valitsen tuon ekan vaihtoehdon. 

```{r, eval=FALSE}

G1=gamm4(terri ~ year + offset(log(area)), random= ~(1 + year|id), family=negbin(theta=Theta), data=dataS) 

G2=gamm4(terri ~ SSS + agri5*year + s(Y) + s(X) + year + offset(log(area)), random= ~(1 + year|id), family=negbin(theta=Theta), data=dataS)

G3=gamm4(terri ~ SSS + agri5*year + s(Y) + s(X)+ year*temp + year*prec + offset(log(area)), random= ~(1 + year|id), family=negbin(theta=Theta), data=dataS)

G4=gamm4(terri ~ SSS + agri5*year + s(Y) + s(X) + year*shan + year*open + offset(log(area)), random= ~(1 + year|id), family=negbin(theta=Theta), data=dataS)

G5=gamm4(terri ~ SSS + agri5*year + s(Y) + s(X) + year*temp + year*prec + year*shan + year*open + offset(log(area)), random= ~(1 + year|id), family=negbin(theta=Theta), data=dataS)


AIC(G1$mer, G2$mer, G3$mer, G4$mer, G5$mer)
```

Malli G4 ei toimi. Miksi sille kuitenkin tulee AIC arvo? 

G3 aj G5 näyttävät saavan pienimmät AIC arvot. Ero näiden välillä on hyvin pieni.




Samat mallit voisi ajaa myös gamm-funktiolla mutta miten tehdään mallin vertailu jos AIC ei ole käytettävissä?

```{r, eval=FALSE}
G1=gamm(terri ~ year, offset=log(area), random= list(id=~1+year), family=nbinom2, data=dataS) 

G2=gamm(terri ~ SSS + agri5*year + s(Y) + s(X) + year , offset=log(area), random= list(id=~1+year), family=nbinom2, data=dataS)

G3=gamm(terri ~ SSS + agri5*year + s(Y) + s(X)+ year*temp + year*prec , offset=log(area), random= list(id=~1+year), family=nbinom2, data=dataS)

G4=gamm(terri ~ SSS + agri5*year + s(Y) + s(X) + year*shan + year*open, offset=log(area), random= list(id=~1+year), family=nbinom2, data=dataS)

G5=gamm(terri ~ SSS + agri5*year + s(Y) + s(X) + year*temp + year*prec + year*shan + year*open, offset=log(area), random= list(id=~1+year), family=nbinom2, data=dataS)

#output1<-model.sel(M1,M2,M3,M4,M5) #tää ei toimi
#output1
```



Lopuksi: Samat mallit voisi tehdä vielä niin, että SSS on eroteltu Abuild + Astream + Aroad + Ariver


## 2.3 Neo-mallit erikseen

Pitäisiköhän nämäkin analyysit tehdä reviiritiheydellä ja GAMM-malleilla?

Heikin graduun:
Lag-malli. Viime vuoden viljely osapopulaation alueella vaikuttaa seuraavan vuoden reviirimääriin.
Aineisto jaetaan kolmeen maantieteelliseen alueeseen. Alueiden vertailu.

```{r, fig.width=14, fig.height=12}

pairs.panels(dataS[,c("terriD","year","neo","agri5","shan","open","X","Y")])
ggplot(dataS, aes(x=year,y=terriD))+ geom_point() + geom_smooth()
```

Neo = lineaarinen, mitä enemmän neonikotinoideja sen vähemmän reviirejä
shan = additiivinen, hyvin yksipuolisesta viljelystä edes muutamaan lajiin siirryttäessä suuri positiivinen vaikutus reviirien määrään, sen jälkeen tasaantuu ja jopa laskee
agri5 = additiivinen, olisko pieni notkahdus reviireissä jos oikein paljon peltoa maisemassa?
open = ei oikein mitään vaikutusta, korreloi neon kanssa
Y = reviirejä enemmän etelässä

```{r, eval=FALSE}
#neot tiheydellä, gamm


#neot offsetilla, glmm
#NO1=lme(terri ~ offset(area) + neo + year + X*Y + (1|fyear) + (1|id), family=nbinom2, data=data)

#lag-malli
#NL1=   (terri ~ neo + year + X + Y + (1|fyear) + (1|id), correlation=corAR1(form=~year) family=nbinom2, data=data)

#neot erikseen
N1=glmmTMB(terri ~ neo * year + X * Y + (1|fyear) + (1|id), family=nbinom2, data=dataS)
summary(N1)

N2=glmmTMB(terri ~ neo + year + X + Y + (1|fyear) + (1|id), family=nbinom2, data=dataS)
AIC(N1,N2)

N3=glmmTMB(terri ~ neo + year  + Y + (1|fyear) + (1|id), family=nbinom2, data=dataS)
AIC(N2,N3)

N4=glmmTMB(terri ~ neo + Y + (1|fyear) + (1|id), family=nbinom2, data=dataS)
AIC(N3,N4)

N5=glmmTMB(terri ~ neo + year  + (1|fyear) + (1|id), family=nbinom2, data=dataS)
AIC(N3,N5)

N6=glmmTMB(terri ~  year + Y + (1|fyear) + (1|id), family=nbinom2, data=dataS)
AIC(N3,N6)

summary(N3)
summary(N6)
```




